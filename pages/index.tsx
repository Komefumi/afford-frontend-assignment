import { useEffect, useState, useCallback } from "react";
import type { ChangeEvent } from "react";
import type { NextPage } from "next";
import Head from "next/head";
import ProductCard from "@ui/ProductCard";
import {
  Grid,
  Container,
  Paper,
  Box,
  Checkbox,
  Button,
  Badge,
  Rating,
  Slider,
  Typography,
} from "@local-mui";
import {
  categories,
  brands,
  mainRatings as predefinedMainRatings,
} from "data/predefined";
import {
  useGetCategoryToProductCount,
} from "state/hooks";
import { useAppSelector, useAppDispatch } from "state/store";
import { useGetSortedProducts } from "state/hooks";
import {
  createSetFilterInLists,
  createSetFilterInRanges,
} from "state/actions/creators";
import { PRODUCT_COUNT, MAX_PRICE } from "config/constants";
import { BrandEnum, RatingEnum } from "types/data";
import {
  StateFiltersListsEnum,
  PriceRangeInterface,
  StateFiltersRangesEnum,
} from "types/state";
import { FilterControlMajorProps } from "types/prop-types";

import classes from "styles/Home.module.scss";

const Home: NextPage = () => {
  const products = useGetSortedProducts();
  return (
    <>
      <Head>
        <title>Fruits and Vegetables - And Other Kitchen Wonders</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Box className={classes.page_wrapper}>
        <Box className={classes.background}>
          <Container maxWidth="lg">
            <Paper elevation={0} className={classes.app_panel}>
              <header className={classes.app_panel_header}>
                <Box className={classes.top_row}>
                  <Typography variant="h4" component="h1">
                    Fruits and vegetables
                  </Typography>
                  <Box className={classes.control_and_stats}>
                    <Box className={classes.controls}>
                      <Button>Grid View</Button>
                      <Button>List View</Button>
                    </Box>
                    <Box className={classes.stats}>
                      <Box className={classes.stat_item}>
                        <Badge
                          className={classes.value}
                          badgeContent={PRODUCT_COUNT}
                        />
                        <Typography
                          className={classes.label}
                          variant="subtitle2"
                        >
                          Products
                        </Typography>
                      </Box>
                    </Box>
                  </Box>
                </Box>
                <Box className={classes.item_listing_controls}>
                  <Box className={classes.control_unit}></Box>
                  <Box className={classes.control_unit}></Box>
                  <Box className={classes.control_unit}></Box>
                  <Box className={classes.control_unit}></Box>
                </Box>
                <Box className={classes.applied_filters_listing}>
                  <Typography variant="body2">Applied filters:</Typography>
                  <Box>Select Filter</Box>
                  <Box>Select Filter</Box>
                </Box>
              </header>
              <main>
                <Grid container spacing={1}>
                  <Grid
                    item
                    container
                    xs={3}
                    className={classes.main_filter_controls}
                  >
                    <CategoriesControl />
                    <BrandsControl />
                    <RatingsControl />
                    <PriceControl />
                  </Grid>
                  <Grid item container xs={9} spacing={3}>
                    {products.map((productItem) => {
                      const { id } = productItem;
                      return (
                        <Grid item key={id} xs={4}>
                          <ProductCard product={productItem} />
                        </Grid>
                      );
                    })}
                  </Grid>
                </Grid>
              </main>
            </Paper>
          </Container>
        </Box>
      </Box>
    </>
  );
};

function FilterControlMajor({ title, children }: FilterControlMajorProps) {
  return (
    <Box>
      <Typography variant="h6" className={classes.filter_control_major_title}>
        {title}
      </Typography>
      <Box>{children}</Box>
    </Box>
  );
}

function CategoriesControl() {
  const categoryToProductCount = useGetCategoryToProductCount();
  return (
    <FilterControlMajor title="Categories">
      <ul className={classes.category_listing}>
        {categories.map((categoryEnumItem) => {
          return (
            <li key={categoryEnumItem}>
              <Box className={classes.category_name}>{categoryEnumItem}</Box>
              <Badge
                badgeContent={categoryToProductCount[categoryEnumItem]}
                className={classes.category_badge}
                color="primary"
              />
            </li>
          );
        })}
      </ul>
    </FilterControlMajor>
  );
}

function BrandsControl() {
  const dispatch = useAppDispatch();
  const { brands: brandsInFilterState } = useAppSelector(
    (state) => state.filters.lists
  );
  const createHandleCheck = useCallback(
    (brandEnumItem: BrandEnum) => {
      return (_event: ChangeEvent<HTMLInputElement>) => {
        const nextBrandsInFilterState = brandsInFilterState.slice();
        const indexOfBrand = nextBrandsInFilterState.indexOf(brandEnumItem);
        if (indexOfBrand === -1) {
          nextBrandsInFilterState.push(brandEnumItem);
        } else {
          nextBrandsInFilterState.splice(indexOfBrand, 1);
        }
        dispatch(
          createSetFilterInLists({
            target: StateFiltersListsEnum.BRANDS,
            nextList: nextBrandsInFilterState,
          })
        );
      };
    },
    [brandsInFilterState]
  );
  return (
    <FilterControlMajor title="Brands">
      <ul className={classes.brand_listing}>
        {brands.map((brandEnumItem) => {
          const isChecked = brandsInFilterState.includes(brandEnumItem);
          return (
            <li key={brandEnumItem}>
              <Checkbox
                className={classes.brand_item_checkbox}
                color="primary"
                checked={isChecked}
                onChange={createHandleCheck(brandEnumItem)}
              />
              <Box>{brandEnumItem}</Box>
            </li>
          );
        })}
      </ul>
    </FilterControlMajor>
  );
}

function RatingsControl() {
  const dispatch = useAppDispatch();
  const mainRatings = useAppSelector(
    (state) => state.filters.lists.mainRatings
  ) as RatingEnum[];
  const createChangeHandler = useCallback(
    (mainRatingItem: RatingEnum) => {
      return (_event: ChangeEvent<HTMLInputElement>) => {
        const indexOfItem = mainRatings.indexOf(mainRatingItem);
        const nextMainRatings = mainRatings.slice();
        if (indexOfItem === -1) {
          nextMainRatings.push(mainRatingItem);
        } else {
          nextMainRatings.splice(indexOfItem, 1);
        }
        dispatch(
          createSetFilterInLists({
            target: StateFiltersListsEnum.MAIN_RATINGS,
            nextList: nextMainRatings,
          })
        );
      };
    },
    [mainRatings]
  );
  return (
    <FilterControlMajor title="Ratings">
      <ul className={classes.item_list}>
        {predefinedMainRatings.map((ratingItem) => {
          const isChecked = mainRatings.includes(ratingItem);
          return (
            <li key={ratingItem}>
              <Checkbox
                checked={isChecked}
                onChange={createChangeHandler(ratingItem)}
              ></Checkbox>
              <Rating value={ratingItem} readOnly />
            </li>
          );
        })}
      </ul>
    </FilterControlMajor>
  );
}

function PriceControl() {
  const dispatch = useAppDispatch();
  const priceRange = useAppSelector(
    (state) => state.filters.ranges.price
  ) as PriceRangeInterface;
  const [priceToBeFed, setPriceToBeFed] = useState([0, MAX_PRICE]);
  const onChangeForSlider = (_event: Event, newValue: number | number[]) => {
    newValue = newValue as number[];
    setPriceToBeFed(newValue);
  };
  const createOnChangeForDirectInput = (minOrMax: "min" | "max") => {
    return function (event: ChangeEvent<HTMLInputElement>) {
      const nextPriceToBeFed = priceToBeFed;
      nextPriceToBeFed[minOrMax === "min" ? 0 : 1] = parseInt(
        event.target.value
      );
      setPriceToBeFed(nextPriceToBeFed);
    };
  };

  const confirmPriceChange = () => {
    dispatch(
      createSetFilterInRanges({
        target: StateFiltersRangesEnum.PRICE,
        nextRange: { min: priceToBeFed[0], max: priceToBeFed[1] },
      })
    );
  };

  const setToConfirmedPrice = () => {};

  useEffect(() => {
    setPriceToBeFed([priceRange.min, priceRange.max]);
  }, [priceRange, setPriceToBeFed]);
  return (
    <FilterControlMajor title="Price">
      <Box className={classes.price_control_body}>
        <Slider
          className={classes.price_range_slider}
          value={priceToBeFed}
          onChange={onChangeForSlider}
          min={0}
          max={MAX_PRICE}
        />
        <Box className={classes.direct_price_input_row}>
          <Box className={classes.direct_price_input_unit}>
            <Typography
              variant="caption"
              className={classes.direct_price_input_label}
            >
              Min
            </Typography>
            <input
              type="number"
              value={priceToBeFed[0]}
              onChange={createOnChangeForDirectInput("min")}
              className={classes.direct_price_input}
            />
          </Box>
          <Box className={classes.direct_price_input_unit}>
            <Typography
              variant="caption"
              className={classes.direct_price_input_label}
            >
              Max
            </Typography>
            <input
              type="number"
              value={priceToBeFed[1]}
              onChange={createOnChangeForDirectInput("max")}
              className={classes.direct_price_input}
            />
          </Box>
        </Box>
        <Box className={classes.price_control_trigger_row}>
          <Button
            onClick={confirmPriceChange}
            color="primary"
            variant="contained"
          >
            Apply
          </Button>
          <Button onClick={setToConfirmedPrice}>Reset</Button>
        </Box>
      </Box>
    </FilterControlMajor>
  );
}
export default Home;
